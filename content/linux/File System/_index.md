+++
title = "File System"
weight = 3
+++

## File System

* File System 소개

{{% notice note %}}
파일 시스템이란 파일의 실제 데이터와 메타데이터(파일의 위치, 크기, 소유자, 허가권 등, ls -al로 볼 수 있는 파일정보)를 유지/저장하는 체계입니다.  
파일에 이름을 붙이고, 저장이나 검색을 위해 논리적으로 그것들이 어디에 위치시켜야 하는지 등을 나타내는 방법입니다. 
도스, 윈도우, OS/2, 매킨토시 및 유닉스 기반의 운영체계들은 모두, 파일들이 어딘가에 계층적인 구조로 위치하는 파일 시스템을 가지고 있습니다.  
파일은 계층구조 내의 바른 위치인 디렉터리 (윈도우95 이후에는 폴더) 또는 서브디렉터리 내에 놓여 집니다. 파일 시스템들은 파일의 이름을 붙이는 규칙을 가지고 있습니다.  
이러한 규칙에는 파일이름의 길이제한, 어떤 글자들이 사용될 수 있는지 등이 포함되며, 몇몇 시스템에서는 파일이름 확장자의 길이조차 제한을 두고 있습니다. 
파일 시스템은 또한 디렉터리 구조를 통하여 파일까지 가는 경로를 설정하는 형식을 포함합니다.  
{{% /notice %}}


* Partition 이란 ?  
> 하드 디스크 및 Storage 를 필요 용도에 따라 나눠 놓는것을 말합니다.  

* Partition image
![D4](/linux/linux_tmp/info/D4.png)  

<br></br>

* MBR (Master Boot Record)

{{% notice info %}}
MBR은 운영체계가 어디에, 어떻게 위치해 있는지를 식별하여 컴퓨터의 주기억장치에 적재될 수 있도록 하기 위한 정보로서 하드디스크나 디스켓의 첫 번째 섹터에 저장되어 있습니다.  
MBR은 또한 "파티션 섹터" 또는 "마스터 파티션 테이블"이라고도 불리는데, 그 이유는 하드디스크가 포맷될 때 나뉘어지는 각 파티션의 위치에 관한 정보를 가지고 있기 때문입니다.  
그외에도, MBR은 메모리에 적재될 운영체계가 저장되어 있는 파티션의 부트 섹터 레코드를 읽을 수 있는 프로그램을 포함하고 있는데, 부트 섹터 레코드에는 다시 운영체계의 나머지 부분들을 메모리에 적재시키는 프로그램을 담고 있습니다. 
{{% /notice %}}


* 주 파티션 (Primary)  
> /boot 디렉토리 및 / 영역을 주로 사용 합니다. 
(4개의 Primary 파티션 또는 3개의 Primary 파티션 + 1개의 Extend 영역으로 구성 할수 있습니다.)  

* 확장 파티션 (Extended)  
> Extended 는 실제로 사용되는 파티션이 아닌, 그 하위에 생성될 Logical 영역 사용하기 위한 영역 입니다.  

* 논리 파티션 (Logical)  
> Extend 파티션으로 만든 파티션으로 Logical 파티션을 구성 할수 있습니다.  

* Logical 영역 참고사항

{{% notice note %}}
RHEL 5 까지는 Logical 영역이 15개로 제한 되어 있었지만 RHEL 6 부터는 제한이 없어 졌으며  
퍼포먼스 이슈로 인하여 15개 이하로 만드는게 좋습니다.
{{% /notice %}}



* File system 요약

{{% notice info %}}
파일 시스템이란 운영제제가 파일을 시스템의 디스크상에 구성하는 방식을 말합니다.  
운영체제는 시스템의 디스크 파티션상에 파일들을 연속적이고 일정한 규칙을 가지고 저장하는데 파일 시스템은 이러한 규칙들의 방식을 제시하는 역할을 합니다.  
{{% /notice %}}

<br></br>

* **File system 구조**  
<br></br>

* 슈퍼 블록 (Super Block)  
> 슈퍼블록(Super Block)은 파일 시스템에 의존하는 정보를 가지며 파일 시스템의 크기 등과 같은 파일 시스템의 전체 적인 정보를 가지고 있습니다.  

* 아이노드 (inode)  
> 아이노드(inode)는 파일의 이름을 제외한 해당 파일의 모든 정보를 가지고 있다. 파일 이름은 inode 번호와 함께 디렉토리 안에 저장됩니다.  

* 데이터 블록 (Data Block)
> 데이터 블록(data block)은 inode에 포함된다. inode가 몇 개의 데이터 블록을 포함하고 있다. 데이터 블록은 파일에서 테이터를 저장하기 위해서 사용됩니다.  

* 디렉토리 블록 (Directory Block)  
> 파일 이름과 inode번호를 저장하기 위해서 사용됩니다.  

* 간접 블록 (Indirection Block)  
> 간접블록은 추가적인 테이터 블록을 위한 포인터들이 사용할 동작으로 할당되는 공간이다. 실제적으로 inode는 적은 수의 테이터 블록을 가지고 있습니다.  
> 그러므로 더 많은 데이터 블록이 필요할 경우 이를 지정할 포인터가 필요하게 되는데 그때 포인터들이 사용할 동적인 블록이 간접 블록입니다.

* 홀 (Hole)  
> 홀은 inode나 간접 블록안의 테이터 블록의 주소로 특별한 값을 저장한다.홀은 파일 시스템에 의해서 파일안에 자리하게 됩니다.
하지만 이 홀을 위해 실질적으로 디스크 상에 공간은 할당되지 않습니다, 단지 0바이트가 파일 안에서 특정 공간을 차지하고 있더라고 가정하는 것  

<br></br>

* 저널링 파일 시스템 이란 ?

{{% notice note %}}
저널링 파일 시스템은 데이터베이스에서 사용하는 저널링 기술을 적용하여 일정부분을 기록에 남겨두어, 
백업 및 복구 능력이 뛰어난 파일 시스템을 말하며,  비정상적인 종료로 인해 수행되는 파일 시스템 복구에 드는 시간이 적게 듭니다.  
{{% /notice %}}

* 리눅스 사용가능  파일 시스템 종류

{{% notice info %}}
리눅스에서 사용하는 표준 파일시스템은 ext, ext2 순서로 발전해 왔으며, 커널 2.4.x부터 ReiserFS, XFS, JFS, ext3 와 같은 새로운 저널링(Journaling) 
파일시스템이 추가 되었습니다.  
RHEL 6 Version 의 경우 ext4 , RHEL 7 Version 의 경우 XFS 가 기본 파일시스템 입니다.  
EXT4 와 XFS 의 경우 자세하게 정리 하였으며 나머지 파일 시스템의 경우 참고 사항만 정리 하였습니다.  
{{% /notice %}}

* JFS/JFS2  
> IBM의 독자적인 저널링 파일 시스템으로, 자사의 하이 엔드 서버와 OS/2 에서 사용할 목적으로 만든 저널링 파일시스템이며 JFS 는 커뮤니티 버전의 리눅스 에서 사용 가능합니다.  
> RHEL 모든 버전의 경우 지원하지 않으며, 권장 하지 않습니다.  


* ReiserFS  
> Hans Reiser가 이끄는 Namesys 팀이 설계하고 구현 한 범용 저널 컴퓨터 파일 시스템입니다.
> GPLv2로 라이센스 된 Linux (할당량 지원없이)에서 지원되며, Linux 커널 2.4.1 버전에서 처음 소개 된이 커널은 표준 커널에 포함될 최초의 저널링 파일 시스템이었습니다.


* EXT
> ext는 ext1 으로도 불리며, 리눅스 운영 체제를 목표로 만들어진 첫번째 파일 시스템입니다.  
> Extended File System을 줄여 extfs 또는 ext로 씁니다.  
> ext는 MFS(MINIX File System)의 한계를 극복하기 위해 만들었으며, 1992년 4월에 구현되어 Linux 0.96c에 추가되었습니다.


* EXT2
> ext2는 1993년 1월에 알파 버전을 공개한 파일 시스템이며, 정식 이름은 Second Extended File System입니다. 
> ext2 파일 시스템은 ext의 문제를 해결하기 위해 나온 파일 시스템입니다.  
> ext에 있었던 여러 단점(분리 접근, 아이노트 수정 등 지원 안 함)도 개선되었습니다.  
> 파일 시스템의 최대 크기는 블록 사이즈에 따라 2 TiB ~ 32 TiB이며, 서브 디렉토리 개수 제한은 32768개입니다.

* EXT3  
> ext3는 2001년 11월에 Linux 2.4.15에 추가되었습니다. 
> ext3 파일 시스템은 ext2 파일 시스템을 바탕으로 만들었기 때문에, ext2 파일 시스템을 자료 손실 없이 ext3 파일 시스템으로 바꿀 수 있습니다.
> 저널링은 주 파일 시스템을 수정하기 전에 저널에 수정 사항을 먼저 기록하여, 전원이 갑자기 나가거나 시스템 충돌이 일어났을 때 데이터 손실 가능성을 줄일 수 있습니다.
> ext3 파일 시스템은 또한 저널링을 할 때 체크섬을 검사하지 않습니다.  
> 한 디렉토리 당 서브 디렉토리 개수 제한은 31998개입니다.

<br></br>


    
* EXT4

{{% notice note %}}
ext4는 ext3에 대한 일련의 하위 호환성 확장 으로 탄생했습니다.  
ext4에의 예비 개발 버전은 버전 2.6.19 포함 된 리눅스 커널을 2008 년 10 월 11 일, ext4를 안정적인 코드로 표시하는 패치는 Linux 2.6.28 소스 코드 저장소에서 병합되었습니다.
ext4 파일 시스템을 포함하는 커널 2.6.28은 2008 년 12 월 25 일에 최종적으로 발표되었습니다.
{{% /notice %}}

## EXT4 주요 특징

> * **대용량 파일 시스템**  
> ext4 파일 시스템은 최대 1 EiB 크기의 파일과 최대 16 TiB 크기의 파일을 지원 합니다.  

> * **Extents**  
> ext2, ext3  block mapping 방식을 extends 방식을 대체 하여 사용합니다. 대용량 파일 성능을 향상 시키고 조각화 현상을 줄여줍니다.

> * **하위 호환성**  
> ext2, ext3 파일시스템을 ext4 방식으로 마운트하여 성능이 향상된 상태로 사용할 수 있습니다.  
> extends를 사용하는 ext4 파티션은 ext3 방식으로 마운트 할수 없습니다.  

> * **저널 체크섬**  
> ext3 파일 시스템에 없었던 저널 체크섬 기능이 추가됨으로써, 파일 시스템 손상 가능성이 더 줄어들었습니다.

> * **지연 할당**  
> ext4는 데이터가 디스크로 플러시 될 때까지 블록 할당을 지연시킵니다.  
> 지연된 할당은 한 번에 많은 양의 데이터를 효율적으로 할당하여 성능을 향상시키고 조각화를 줄여줍니다. 

> * **무제한의 하위 디렉토리**  
> ext4 는 서브 디렉토리를 무제한으로 허용합니다. (ext3 에서는 최대 32,000 서브 디렉토리를 가질수 있습니다.)  

> * **저널 체크섬**  
> ext4는 신뢰성을 향상시키기 위해 저널의 체크섬 을 사용합니다.  
> 저널링 중에 디스크 입출력 대기를 안전하게 피할 수 있으므로 성능이 향상됩니다.  

> * **신속한 파일 시스템 검사**  
> ext4는 디스크 검사를 할 때 사용하지 않는 부분은 건너뜀으로써 시스템 검사를 빨리 할 수 있습니다.

> * **파일스탬프 향상**  
>  ext4는 나노초 단위로 측정 된 타임 스탬프를 제공하며,날짜 생성 타임 스탬프에 대한 지원이 추가되었습니다.  

* XFS

{{% notice info %}}
XFS 는 SGI ( Silicon Graphics, Inc )가 1993 년에 만든 고성능 64 비트 저널링 파일 시스템이며, 수많은 사이트에서 검증된 파일시스템 입니다.  
XFS는 2001 년 리눅스 커널 에 포팅되었습니다 . 2014 년 6 월부터 XFS는 대부분의 Linux 배포 에서 지원되며 일부 Linux의 기본 파일 시스템으로 사용됩니다.  
{{% /notice %}}
    

## XFS 주요 특징

> * 32Bit OS에선 16TB까지 지원 합니다. RHEL 7 에서 지원하는 파일시스템 크기는 500T입니다.  
> * XFS는 파일 시스템 메타 데이터 저널링을 제공합니다.  
> * xfs_grouwfs 를 사용하여 마운트된 상태에서도 파일시스템 확장이 가능합니다.  
> * 쿼터 저널링 사용으로 충돌후 할당량 일관성 검사를 회피함으로 빠른 복구가 가능 합니다.  
> * 파일시스템 생성 속도가 빠릅니다.  
> * 네이티브 백업 및 restore 유틸이 있습니다. ( xfsdump , xfsrestore )  
> * XFS의 직접 I/O는 응용 프로그램과 저장 장치간에 직접 DMA를 수행하여 장치의 전체 I/O 대역폭을 활용하여 높은 처리량, 캐시되지 않은 I/O를 구현합니다.  
> * XFS는 파일 시스템이 마운트 될 때 초기화되는 블록 및 inode 사용에 대한 사용자, 그룹 및 프로젝트 디스크 할당량을 할수 있습니다.  


* Linux filesystem 참고 사항 [RHEL file system limitations](https://access.redhat.com/solutions/1532)  

* Certified and [Maximum] (individual) file size  

|Filesystem   	|RHEL 3   	|RHEL 4   	|RHEL 5   	|RHEL 6   	|RHEL 7   	|
|---	|---	|---	|---	|---	|---	|
|EXT2/3   	|1TiB (3.0) 2TiB (3.5+)   	|2TiB   	|2TiB   	|2TiB   	|2TiB   	|
|EXT4   	|n/a   	|n/a   	|16TiB (5.6+)   	|16TiB   	|16TiB   	|
|GFS1   	|2TiB   	|16TiB [8EiB]   	|16TiB [8EiB]   	|n/a   	|n/a   	|
|GFS2   	|n/a   	|n/a   	|100TiB (5.3+) [8EiB]   	|100TiB [8EiB]   	|100TiB [8EiB]   	|
|XFS   	|n/a   	|n/a   	|100TiB [8EiB]   	|100TiB [8EiB]   	|500TiB [8EiB]   	|

* Certified and [Maximum] filesystem size  

|Filesystem   	|RHEL 3   	|RHEL 4   	|RHEL 5   	|RHEL 6   	|RHEL 7  	|
|---	|---	|---	|---	|---	|---	|
|EXT2/3   	|1TiB (3.0) 2TiB(3.5+)[8TiB]   	|8TiB   	|8TiB (5.0), 16TiB (5.1+)    	|16TiB   	|16TiB   	|
|EXT4   	|n/a   	|n/a   	|16TiB [1EiB] (5.6+)   	|16TiB [1EiB]   	|50TiB [1EiB]   	|
|GFS    	|2TiB   	|	16TiB [8EiB]   	| 16TiB [8EiB]  	|n/a   	|n/a   	|
|GFS2   	|n/a   	|n/a   	|100(5.3+)TiB [8EiB]   	|100TiB [8EiB]   	|100TiB [8EiB]   	|
|XFS   	|n/a   	|n/a   	|100TiB [16EiB]   	|300TiB [16EiB]   	|500TiB [16EiB]   	|



<br></br>